## 嵌入式开发C语言基础
### 一、位操作

| 运算符 | 含义 | 示例 |
| :------:| :------: | :------: |
| & | 按位与 | |
| &#124; | 按位或 | |
| ^ | 按位异或 | |
| ~ | 取反 | |
| << | 左移 | |
| >> | 右移 | |

- 不改变其他位的值的状态下，对某几位进行设置初始值

先对需要设置的位用 & 操作符（对应位&0）进行清零操作：

    GPIOA-> BSRRL &=0XFF0F;  //将第 4-7 位清 0

然后用 | 操作符设值（对应位|你想要设定的值）： 

    GPIOA-> BSRRL |=0X0040; //设置相应位的值，不改变其他位的值


- 移位操作提高代码的可读性

移位操作在单片机开发中非常重要，固件库中GPIO初始化的函数里面有一行代码

    GPIOx->ODR |= (((uint32_t)0x01) << pinpos);

这个操作就是将 ODR 寄存器的第 pinpos 位设置为 1，为什么要通过左移而不是直接设置一个固定的值呢？这是为了提高代码的可读性以及可重用性。这行代码可以很直观明了的知道，是将第 pinpos 位设置为 1。如果写成`GPIOx->ODR =0x0040; `就不够直观。  

- 取反操作使用技巧   

SR 寄存器的每一位都代表一个状态，某个时刻我们希望去设置某一位的值为 0，同时其他位都保留为 1，简单的作法是直接给寄存器设置一个值：

    TIMx->SR=0xFFF7；

这样的作法设置第 3 位为 0，但是这样的作法同样不好看，并且可读性很差。看看库函数代码的做法：

    TIMx->SR &= (uint16_t)~TIM_FLAG;

而 TIM_FLAG 是通过宏定义定义的值：

    #define TIM_FLAG  ((uint16_t)0x0001) 

可以直接从宏定义中看出 TIM_FLAG_ 就是设置的第 0位了，可读性非常强。

### 二、结构体



### 三、全局变量

1. 不要在头文件中对变量进行定义
1. 头文件中变量的声明添加关键字 extern
1. 在相应的 .c 文件中对变量进行定义    

![extern](/extern.png)